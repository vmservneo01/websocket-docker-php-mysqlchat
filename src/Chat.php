<?php
// This is our custom WebSocket handler class (that implements the 'MessageComponentInterface' of the Ratchet library)
// Note: If you edit/change any code that is related to the WebSocket Server (i.e. Ratchet library) (example: If you edit/change any code in Chat.php class), you must restart the WebSocket Server in order for the changes to take effect (by opening the terminal and stopping the already running WebSocket Server by CTRL + C, then starting it again by using the    "php bin/server.php"    command).

namespace MyApp;
use Ratchet\MessageComponentInterface;
use Ratchet\ConnectionInterface;
require dirname(__DIR__) . "/database/ChatUserModel.php";
require dirname(__DIR__) . "/database/GroupChatMessageModel.php";
require dirname(__DIR__) . "/database/PrivateChatMessageModel.php";



class Chat implements MessageComponentInterface { // The 'Chat' class is our custom WebSocket handler class that implements the 'MessageComponentInterface' of the Ratchet library
    protected $clients;

    public function __construct() {
        $this->clients = new \SplObjectStorage;
        echo 'Server Started';
    }

    public function onOpen(ConnectionInterface $conn) { // Note:    $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
        // Store the new connection to send messages to later
        echo 'Server Started';

        $this->clients->attach($conn);


        // Disply the Online/Offline Status (here 'Online' Status because we're inside onOpen() method) of all users/clients based on the onOpen() and onClose() methods (in case of 'One-to-One/Private' Chat ONLY, not 'Group' Chat. With 'Group' Chat, we depended on the `user_login_status` column of `chat_application_users` table) (This script is repeated inside the onClose() method of this class too for the Online/Offline Status too (Online Status))
        $querystring = $conn->httpRequest->getUri()->getQuery(); // Get the 'token' we ourselves generated upon user login in index.php, and then JavaScript (client side) passes it in the URL as a query string paramter in private_chat.php (i.e.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    )    // Example:    token=014c3972efce8dc679b25d45a2ce2bd6
        // echo '<pre>', var_dump($querystring), '</pre>';



        parse_str($querystring, $queryarray);

        if (isset($queryarray['token'])) // Display User Online/Offline Status in case of 'One-to-One/Private' Chat only    // If the chat is 'One-to-One' or 'Private' Chat (not 'Group' Chat) i.e. The JavaScript WebSocket Constructor function URL contains a 'token' as a query string parameter e.g.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    (which comes from the JavaScript in private_chat.php)
        {
            // Get the user's `user_id` that just opened the WebSocket Connection from `chat_application_users` table based on the 'token' (i.e. `user_token` column) passed as a query string parameter in the URL (coming from    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    in client side (JavaScript) in private_chat.php). This is to eventually send that went online user `user_id` and    $data['status_type'] = 'Online';   to all One-to-One/Private Chat Users to display User Online/Offline Status (here 'Online')
            $user_object = new \ChatUserModel;

            $user_object->setUserToken($queryarray['token']); // We set the 'token' in order to use it to get the `user_id` from `chat_application_users` table (by using the    get_user_id_from_token()    method)
            $user_object->setUserConnectionId($conn->resourceId); // Note:    $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
            $user_object->update_user_connection_id(); // Store the unique WebSocket Connection ID (also AKA WebSocket Session ID) of the client (user) in the `user_connection_id` column in `chat_application_users` table which is generated by the WebSocket Connection for every client (user)
            $user_data = $user_object->get_user_id_from_token(); // We use this method as we have previously set the user's token using    setUserToken()    method in the last couple of lines of code

            $user_id = $user_data['user_id'];

            $data['user_id']     = $user_id; // Append 'user_id'     to the $data array to be sent to the client side to display real-time User Online/Offline Status
            $data['status_type'] = 'Online'; // Append 'status_type' to the $data array to be sent to the client side to display real-time User Online/Offline Status

            // first, you are sending to all existing users message of 'new'
            foreach ($this->clients as $client)
            {
                // Important: Sending this $data array variable (using    $client->send(json_encode($data));    ) from onOpen() or onClose() methods (or any methods of Chat.php Class, in general) (using    $client->send()    ) here (we're on the server-side) triggers the    conn.onmessage    event on the client side (JavaScript) in private_chat.php i.e.    conn.onmessage = function(e) {
                $client->send(json_encode($data)); // here we are sending a status-message    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in group_chat.php
            }
        }

        // echo '<pre>', var_dump($conn->resourceId), '</pre>'; // Example:    51
        echo "New connection! ({$conn->resourceId})\n"; // $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
    }

    public function onMessage(ConnectionInterface $from, $msg) { // $from and $msg (they are the 'userId' key and 'msg' key of the 'data' JavaScript object in group_chat.php) inside the JavaScript 'data' variable in group_chat.php) are sent by JavaScript (under the "Handling Chat HTML Form Submission" Section in group_chat.php) using the    conn.send()    function in group_chat.php    // This method is triggered when a chat message is sent from the client side group_chat.php (via JavaScript in the <script> tag), then it takes this message and, in turn, it sends it to all other clients (receivers), including the sender themselves    // $from and $msg    are the JSON 'data' JavaScript Object (converted to JSON) sent from the client side WebSocket ($from is the 'userId' key, and $msg is the 'msg' key that are sent from client side (JavaScript) when the Chat HTML Form is submitted using JavaScript in group_chat.php or private_chat.php. Check the <script> HTML tag in the same file (Under the "Handling Chat HTML Form Submission" Section in group_chat.php)), and it's passed on (sent again) to all other connected users' client side (i.e. Browser/JavaScript) (it's sent again to all users's client side (Browser/JavaScript) connected to the chat WebSocket)    // Note: The    resourceId    property, which is the unique identifier (i.e. WebSocket Connection ID AKA WebSocket Session ID) that the WebSocket Connection (Ratchet) randomly generates for every client (user) connected a WebSocket Connection, is present/exists/available in the following objects in Ratchet library:    $conn->resourceId (assigned by WebSocket Connection (Ratchet)),    $client->resourceId (assigned by WebSocket Connection (Ratchet)) (N.B. You have to use    foreach ($this->clients as $client) {    first.), and    $from->resourceId (This is not a WebSocket Connection ID, but rather the `user_id` column (in `chat_application_users` database table) of the message sender that we assign ourselves, and we send it from the client side (JavaScript) from the    conn.send()    JavaScript function in group_chat.php and private_chat.php to the onMessage() method of the Chat.php Class)
        $numRecv = count($this->clients) - 1;
        echo sprintf('Connection %d sending message "%s" to %d other connection%s' . "\n" // This message is printed (echo-ed) inside your WebSocket Server's terminal/command-line window / Command Line window
            , $from->resourceId, $msg, $numRecv, $numRecv == 1 ? '' : 's');


        $data = json_decode($msg, true); // Convert $msg from JSON to a PHP array    // Example (PHP array):    ['userId' => 11, 'msg' => 'how are you?']    // This $msg (of JSON type, then we converted it to a PHP array) is sent from the client side (JavaScript) in group_chat.php


        // One-to-One/Private Chat
        if (isset($data['command']) && $data['command'] == 'private') // If the    command: 'private'    key-value pair is sent with the    conn.send()    function in group_chat.php or private_chat.php, this means this is a 'ONE-TO-ONE/PRIVATE' Chat message, NOT a 'Group' Chat message
        {
            // To store 'One-to-One/Private' Chat messages in the `private_chat_messages` database table (to save and display the One-to-One/Private Chat History)
            $private_chat_object = new \PrivateChatMessageModel;

            $private_chat_object->setToUserId($data['receiver_userid']); // Private Message Sender's   `to_user_id`   column in `private_chat_messages` table    // $data is sent by the    conn.send()    JavaScript function in group_chat.php or private_chat.php
            $private_chat_object->setFromUserId($data['userId']);        // Private Message Receiver's `from_user_id` column in `private_chat_messages` table    // $data is sent by the    conn.send()    JavaScript function in group_chat.php or private_chat.php
            $private_chat_object->setChatMessage($data['msg']); // $data is sent by the    conn.send()    JavaScript function in group_chat.php or private_chat.php
            $timestamp = date('Y-m-d h:i:s');
            $private_chat_object->setTimestamp($timestamp);
            $private_chat_object->setStatus('Yes');
            $chat_message_id = $private_chat_object->save_chat(); // This save_chat() method return the ID of the last inserted One-to-One/Private Chat message (in `private_chat_messages` table)


            $user_object = new \ChatUserModel;

            // Get One-to-One/Private Chat message sender's data from `chat_application_users` table
            $user_object->setUserId($data['userId']); // $data is sent by the    conn.send()    JavaScript function in group_chat.php or private_chat.php
            $sender_user_data = $user_object->get_user_data_by_id();
            $sender_user_name = $sender_user_data['user_name']; // The sender's `user_id` column in `chat_application_users` table

            // Get One-to-One/Private Chat message receiver's data from `chat_application_users` table
            $user_object->setUserId($data['receiver_userid']);
            $receiver_user_data = $user_object->get_user_data_by_id();
            $receiver_user_connection_id = $receiver_user_data['user_connection_id']; // The receiver's `user_connection_id` column of `chat_application_users` table

            // $sender_user_name = $sender_user_data['user_name'];
            $data['datetime'] = $timestamp; // Append 'datetime' array key to be eventually sent to the targeted/specific/particular 'One-to-One/Private' Chat user as JSON
            // $receiver_user_connection_id = $receiver_user_data['user_connection_id'];

            foreach ($this->clients as $client)
            {
                // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                if ($from == $client) // If the user/client is the original message sender themselves (If the client is the message sender, so this means they will receive the same (their) sent message on the client side (JavaScript))
                {
                    $data['from'] = 'Me'; // Include the chat message sender's name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }
                else // If the user/client is NOT the original message sender
                {
                    $data['from'] = $sender_user_name; // Include the chat message sender's name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }


                if ($client->resourceId == $receiver_user_connection_id || $from == $client) // If the current session client's/user's unique WebSocket Connection ID (AKA WebSocket Session ID) which is generated by the WebSocket Connection (Ratchet) is equal to the receiver's WebSocket Connection ID which we have previously stored in the `user_connection_id` column in `chat_application_users` table (which means THIS is the TARGETED/PARTICULAR/SPECIFIC user to send the message to, and they (he/she) are currently ONLINE i.e. currently CONNECTED to the WebSocket Connection), OR, the clinet/user is the original message sender themselves (he/she) (i.e. if the sender is the receiver) (meaning send the message to the original sender again, too)
                {   
                    // Note: Sending data from any methods of the custom WebSocket Handler Chat.php Class (using    $client->send()    ) triggers the    conn.onmessage    event in JavaScript on the client side (here in this project, in private_chat.php or group_chat.php) (i.e. It doesn't trigger the    conn.onopen    or    conn.onclose    JavaScript events!)
                    $client->send(json_encode($data)); // The sender is not the receiver, send to each client connected    // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in group_chat.php
                }
                else // If the targeted/specific/particular client (user) who should be receiving the message is currently OFFLINE (i.e. not connected at the moment to the WebSocket Connection), don't send the message, and UPDATE the message's `status` column in `private_chat_messages` table from 'Yes' to 'No' (i.e. 'Unread' message)
                {
                    $private_chat_object->setStatus('No');
                    $private_chat_object->setChatMessageId($chat_message_id);

                    $private_chat_object->update_chat_status();
                }
            }
        }
        else // Group Chat    // If the    command: 'private'    key-value pair is NOT sent with the    conn.send()    function in group_chat.php or private_chat.php, this means this is a 'GROUP' Chat message, NOT a 'One-to-One/Private' Chat message
        {
            // Group Chat
            // To store 'Group' Chat messages in the `group_chat_messages` database table (to save and display the Group Chat History)
            $chat_object = new \GroupChatMessageModel; // To store the chat messages in the `group_chat_messages` database table (to display the Chat History)

            $chat_object->setUserId($data['userId']); // 'userId' which came from the client side (JavaScript) in group_chat.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in group_chat.php)
            $chat_object->setMessage($data['msg']);   // 'msg'    which came from the client side (JavaScript) in group_chat.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in group_chat.php)
            $chat_object->setCreatedOn(date("Y-m-d h:i:s"));
            $chat_object->save_chat(); // save_chat() method returns a Boolean (true or false)



            $user_object = new \ChatUserModel;

            $user_object->setUserId($data['userId']); // 'userId' which came from the client side (JavaScript) in group_chat.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in group_chat.php)
            $user_data = $user_object->get_user_data_by_id();

            $user_name  = $user_data['user_name']; // We get the $user_name of the message sender and the time when that message was sent (to send them to the client side as JSON in order to display them on the client side using JavaScript)
            $data['dt'] = date("d-m-Y h:i:s");     // We get the $user_name of the message sender and the time when that message was sent (to send them to the client side as JSON in order to display them on the client side using JavaScript)



            foreach ($this->clients as $client) {
                // Note: This following if condition allows sending the message to the receivers ONLY, meaning it doesn't send the message to the original sender (because they (the sender) already are the sender), but it sends it to just the receivers only. (N.B. Sending is for the client side (JavaScript in group_chat.php))
                /*if ($from !== $client) { // N.B. Don't show (send) the sent message to the original sender of this message! But show (send) it to the receivers only! (N.B. Sending is for the client side (JavaScript in group_chat.php))
                    // The sender is not the receiver, send to each client connected
                    $client->send($msg); // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in group_chat.php
                }*/

                // Note: Here we send the message to BOTH the sender and receivers (but in case of the current user is the original sender, we include    $data['from'] = 'Me'    with the message (i.e. $data variable) sent to the client side, and in case of the current user is not the sender of that message (a receiver), we include    $data['from'] = $user_name;    with the message (i.e. $data variable) sent to the client side)
                // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                if ($from == $client) // If the user is the original sender of the messsage (i.e. Send/Make    $data['from'] = 'Me'    for the original sender of the message, and Send/make it    $data['from'] = $user_name;    for the rest of the receivers of that message)    // If the user/client is the original message sender themselves (If the client is the message sender, so this means they will receive the same (their) sent message on the client side (JavaScript))
                {
                    $data['from'] = 'Me'; // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }
                else // If the user is NOT the sender of the message (they are just a receiver) (i.e. Send/Make    $data['from'] = 'Me'    for the original sender of the message, and send/make it    $data['from'] = $user_name;    for the rest of the receivers of that message)    // If the user/client is NOT the original message sender
                {
                    $data['from'] = $user_name;  // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }

                // Send the $data variable (the message and other data) to the client side (Check the <script> tag in group_chat.php)
                $client->send(json_encode($data)); // The sender is not the receiver, send to each client connected    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in group_chat.php    // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
            }
        }
    }

    public function onClose(ConnectionInterface $conn) {

        // Disply the Online/Offline Status (here 'Offline' Status because we're inside onClose() method) of all users/clients based on the onOpen() and onClose() methods (in case of 'One-to-One/Private' Chat ONLY, not 'Group' Chat. With 'Group' Chat, we depended on the `user_login_status` column of `chat_application_users` table) (This script is repeated inside the onOpen() method of this class too for the Online/Offline Status too (Offline Status))
        $querystring = $conn->httpRequest->getUri()->getQuery(); // Example:    token=014c3972efce8dc679b25d45a2ce2bd6    // This is the `user_token` we created by ourselves upon every user login process

        parse_str($querystring, $queryarray);

        if (isset($queryarray['token'])) // Display User Online/Offline Status in case of 'One-to-One/Private' Chat only    // If the chat is 'One-to-One' or 'Private' Chat (not 'Group' Chat) i.e. The JavaScript WebSocket Constructor function URL contains a 'token' as a query string parameter e.g.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    (which comes from the JavaScript in private_chat.php)
        {
            // Get the user's `user_id` that closed the WebSocket Connection from `chat_application_users` table based on the 'token' (i.e. `user_token` column) passed as a query string parameter in the URL (coming from    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    in client side (JavaScript) in private_chat.php). This is to eventually send that went offline user `user_id` and    $data['status_type'] = 'Offline';   to all One-to-One/Private Chat Users to display User Online/Offline Status (here 'Offline')
            $user_object = new \ChatUserModel;

            $user_object->setUserToken($queryarray['token']);
            $user_data = $user_object->get_user_id_from_token();
            $user_id = $user_data['user_id'];

            $data['user_id']     = $user_id;  // Append 'user_id'     to the $data array to be sent to the client side to display real-time User Online/Offline Status
            $data['status_type'] = 'Offline'; // Append 'status_type' to the $data array to be sent to the client side to display real-time User Online/Offline Status

            foreach ($this->clients as $client)
            {
                // Important: Sending this $data array variable (using    $client->send(json_encode($data));    ) from onOpen() or onClose() methods (or from any methods of Chat.php Class, in general) (using    $client->send()    ) here (we're on the server-side) triggers the    conn.onmessage    event on the client side (JavaScript) in private_chat.php i.e.    conn.onmessage = function(e) {
                $client->send(json_encode($data)); // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in group_chat.php
            }
        }

        // The connection is closed, remove it, as we can no longer send it messages
        $this->clients->detach($conn);

        echo "Connection {$conn->resourceId} has disconnected\n";
    }

    public function onError(ConnectionInterface $conn, \Exception $e) {
        echo "An error has occurred: {$e->getMessage()}\n";

        $conn->close();
    }
}

?>